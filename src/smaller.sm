let
    Token = {
        Identifier: 0,
        Integer: 1,
        Float: 2,
        String: 3,

        Lambda: 4,
        Dot: 5,
        Comma: 6,
        Colon: 7,
        Equal: 8,
        Project: 9,
        LParen: 10,
        RParen: 11,
        LBrack: 12,
        RBrack: 13,
        LBrace: 14,
        RBrace: 15,

        In: 16,
        Let: 17,
        Match: 18,
        Null: 19,

        EOF: 20,
        Error: 21,

    },

    NodeKind = {
        Literal: 0,
        Reference: 1,
        Let: 2,
        Binding: 3,
        Lambda: 4,
        Call: 5,
        Record: 6,
        Member: 7,
        Array: 8,
        Select: 9,
        Index: 10,
        Projection: 11,
        Match: 12,
        MatchClause: 13,
    },

    LiteralKind = {
        Int: 0,
        Float: 1,
        String: 2,
        Null: 3,
    },

    LiteralInt = /(value).{ kind: NodeKind.Literal, literal: LiteralKind.Int, value },
    LiteralFloat = /(value).{ kind: NodeKind.Literal, literal: LiteralKind.Float, value },
    LiteralString = /(value).{ kind: NodeKind.Literal, literal: LiteralKind.String, value },
    LiteralNull = /(value).{ kind: NodeKind.Literal, literal: LiteralKind.Null, value: null },

    Reference = /(name).{ kind: NodeKind.Reference, name },
    Let = /(name, body).{ kind: NodeKind.Let, name, body },
    Binding = /(name, value).{ kind: NodeKind.Binding, name, value },
    Lambda = /(parameters, body).{ kind: NodeKind.Lambda, parameters, body },
    Call = /(target, args).{ kind: NodeKind.Call, target, args },
    Record = /(members).{ kind: NodeKind.Record, members },
    Member = /(name, value).{ kind: NodeKind.Member, name, value },
    Array = /(values).{ kind: NodeKind.Array, values },
    Select = /(target, name).{ kind: NodeKind.Select, target, name },
    Index = /(target, index).{ kind: NodeKind.Index, target, index },
    Projection = /(value).{ kind: NodeKind.Projection, value },
    Match = /(target, clauses).{ kind: NodeKind.Match, target, clauses },
    MatchClause = /(pattern, value).{ kind: NodeKind.MatchClause, pattern, value },

    tokenToString = /(token).match token {
        Token.Identifier in "Identifier",
        Token.Integer in "Integer",
        Token.Float in "Float",
        Token.String in "String",
        Token.Lambda in "Lambda",
        Token.Dot in "Dot",
        Token.Comma in "Comma",
        Token.Colon in "Colon",
        Token.Equal in "Equal",
        Token.Project in "Project",
        Token.LParen in "LParen",
        Token.RParen in "RParen",
        Token.LBrack in "LBrack",
        Token.RBrack in "RBrack",
        Token.LBrace in "LBrace",
        Token.RBrace in "RBrace",
        Token.In in "In",
        Token.Let in "Let",
        Token.Match in "Match",
        Token.Null in "Null",
        Token.EOF in "EOF",
        Token.Error in "Error",
    },

    nodeKindToString = /(kind).match kind {
        NodeKind.Literal in "Literal",
        NodeKind.Reference in "Reference",
        NodeKind.Let in "Let",
        NodeKind.Binding in "Binding",
        NodeKind.Lambda in "Lambda",
        NodeKind.Call in "Call",
        NodeKind.Record in "Record",
        NodeKind.Member in "Member",
        NodeKind.Array in "Array",
        NodeKind.Select in "Select",
        NodeKind.Index in "Index",
        NodeKind.Projection in "Projection",
        NodeKind.Match in "Match",
        NodeKind.MatchClause in "MatchClause",
    },

    literalKindToString = /(kind).match kind {
        LiteralKind.Int in "Int",
        LiteralKind.Float in "Float",
        LiteralKind.String in "String",
        LiteralKind.Null in "Null",
    },
in
    [
        tokenToString(Token.In),
        nodeKindToString(NodeKind.Array),
        literalKindToString(LiteralKind.Float)
    ]